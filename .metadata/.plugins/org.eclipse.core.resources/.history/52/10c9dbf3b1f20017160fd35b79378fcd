#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
using namespace std;

int N = 41;
int pathColor = 8;
int deadEndColor = 9;

struct Cell{

	/* DO NOT MODIFY THIS */

	int x, y;

	Cell(int x, int y){
		this->x = x;
		this->y = y;
	}

	bool operator==(const Cell& b) const{
		return x==b.x && y==b.y;
	}

};

struct Ocean{

	/* DO NOT MODIFY THIS */

	Cell *nemo, *marlin;
	vector<vector<Cell*> > cells;
	vector<string> matrix;
	int** mark; //of size [N][N]

	Ocean(vector<vector<Cell*> > cells, vector<string> matrix){
		this->cells = cells;
		this->matrix = matrix;
		mark = new int*[N];
		for(int i=0;i<N;i++){
			mark[i] = new int[N];
			for(int j=0;j<N;j++){
				mark[i][j] = -1;
				if(matrix[i][j]=='N')
					nemo = cells[i][j];
				if(matrix[i][j]=='M')
					marlin = cells[i][j];
			}
		}
	}

	Cell* west(Cell* c){
		return cells[c->x][c->y-1];
	}

	Cell* south(Cell* c){
		return cells[c->x+1][c->y];
	}

	Cell* east(Cell* c){
		return cells[c->x][c->y+1];
	}

	Cell* north(Cell* c){
		return cells[c->x-1][c->y];
	}

	vector<Cell*> neighbors(Cell* c){ // in order WSEN
		vector<Cell*> v;
		if(c->y>0)
			v.push_back(west(c));
		if(c->x<N-1)
			v.push_back(south(c));
		if(c->y<N-1)
			v.push_back(east(c));
		if(c->x>0)
			v.push_back(north(c));
		return v;
	}

	bool isWall(Cell* c){
		return matrix[c->x][c->y] == '#';
	}

	void setMark(Cell* c){
		mark[c->x][c->y] = 0;
	}

	void setMark(Cell* c, int v){
		mark[c->x][c->y] = v;
	}

	void unMark(Cell* c){
		mark[c->x][c->y] = -1;
	}

	int getMark(Cell* c){
		return mark[c->x][c->y];
	}

	bool isMarked(Cell* c){
		return mark[c->x][c->y] >= 0;
	}

	void printMarked(){ //print out the paths in the labyrinth
		for(int i=0;i<N;i++){
			for(int j=0;j<N;j++){
				if(matrix[i][j]=='#'||matrix[i][j]=='N'||matrix[i][j]=='M')
					cout<<matrix[i][j];
				else if(mark[i][j]==pathColor)
					cout<<'.';
				else if(mark[i][j]==deadEndColor)
					cout<<'X';
				else
					cout<<' ';
			}
			cout<<endl;
		}
	}

	/* DEFINES THE METHODS TO BE COMPLETED LATER */
	bool dfsFrom(Cell*); //return true if there is a path from c to nemo
	void dfs(); //performs a dfs search
	void bfs(); //performs a bfs search
	void bfsWithDistance(); //bfs with distance
	void bfsWithShortestPath(); //bfs that also marks (one of) the shortest path
	void backTrack(); //auxiliary method for bfsWithShortestPath()

};

Ocean readFile(string fileName){

	/* DO NOT MODIFY THIS */

	vector<vector<Cell*> > cells(N, vector<Cell*>(N));
	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++)
			cells[i][j] = new Cell(i, j);

	string s;
	vector<string> matrix;
	ifstream fin(fileName); //41*41
	while(getline(fin,s))
		matrix.push_back(s);
	fin.close();

	Ocean* o = new Ocean(cells, matrix);
	return *o;
}

ostream& operator<<(ostream &strm, const Cell &c) { //Cell tostring
	return strm<<"("<<c.x<<" "<<c.y<<")";
}

ostream& operator<<(ostream &strm, const Ocean &o) { //Ocean tostring
	for(string x : o.matrix)
		strm<<x<<endl;
	return strm;
}

/* METHODS TO BE COMPLETED */

bool Ocean::dfsFrom(Cell* c){
	if(*c==*(nemo))
		return true;
	if(isWall(c)||isMarked(c))
		return false;
	setMark(c);
	for (Cell* n : neighbors(c)) {
		if (dfsFrom(n)) {
			setMark(c, pathColor);
			return true;
		}
	}
	setMark(c, deadEndColor);
	return false;
}

void Ocean::dfs(){
	dfsFrom(marlin);
}

void Ocean::bfs(){
	queue<Cell*> toBeVisited;
	toBeVisited.push(marlin);
	setMark(marlin, pathColor);
	while(!toBeVisited.empty()){
		Cell* c = toBeVisited.front();
		toBeVisited.pop();
		if(*c==*nemo)
			return;
		for(Cell* n : neighbors(c)){
			if(!isMarked(n)&&!isWall(n)){
				setMark(n, pathColor);
				toBeVisited.push(n);
			}
		}
	}
}

void Ocean::bfsWithDistance(){
	queue<Cell*> toBeVisited;
	toBeVisited.push(marlin);
	setMark(marlin, 0);
	while(!toBeVisited.empty()){
		Cell* c = toBeVisited.front();
		toBeVisited.pop();
		if(*c==*nemo)
			return;
		int cMark = getMark(c);
		for(Cell* n : neighbors(c)){
			if(!isMarked(n)&&!isWall(n)){
				setMark(n, cMark+1);
				toBeVisited.push(n);
			}
		}
	}
}

const int WEST = 0, SOUTH = 1, EAST = 2, NORTH = 3;

void Ocean::backTrack(){
	cout<<"g";
	Cell* c = nemo;
	while(!(*c == *marlin)){
		Cell* d = NULL;
		switch(getMark(c)){
		case WEST: d = west(c); break;
		case SOUTH: d = south(c); break;
		case EAST: d = east(c); break;
		case NORTH: d = north(c); break;
		}
		setMark(c, pathColor);
		c = d;
		cout<<*c<<endl;
	}
}

void Ocean::bfsWithShortestPath(){
	queue<Cell*> toBeVisited;
	toBeVisited.push(marlin);
	setMark(marlin);
	while(!toBeVisited.empty()){
		Cell* c = toBeVisited.front();
		toBeVisited.pop();
		if(*c==*nemo)
			break;
		int dir[] = {EAST, NORTH, WEST, SOUTH};
		int k = 0;
		for(Cell* n : neighbors(c)){
			if(!isMarked(n)&&!isWall(n)){
				setMark(n, dir[k]);
				toBeVisited.push(n);
			}
			k++;
		}
	}
	backTrack();
}

int main() {

	Ocean o = readFile("labyrinth.txt");

	/* TEST THIS TWO LINES TO SEE THE LABYRINTH */
//	cout<<"The ocean looks like..."<<endl;
//	cout<<o<<endl;

	/* HOMEWORK TO BE COMPLETED */
	/* DFS */
//	o.dfs();
//	o.printMarked();

	/* BFS */
//	o.bfs();
//	o.printMarked();

	/* BFS WITH DISTANCE */
//	o.bfsWithDistance();
//	cout<<"Distance to Nemo : "<<o.getMark(o.nemo)<<endl; //true = 104

	/* BFS WITH SHORTEST PATH */
	o.bfsWithShortestPath();
//	for(int i=0;i<N;i++){
//		for(int j=0;j<N;j++){
//			if(o.matrix[i][j]=='#'||o.matrix[i][j]=='N'||o.matrix[i][j]=='M')
//				cout<<o.matrix[i][j];
//			else{
//				switch(o.mark[i][j]){
//				case WEST: cout<<'>'; break;
//				case SOUTH: cout<<'^'; break;
//				case EAST: cout<<'<'; break;
//				case NORTH: cout<<'v'; break;
//				}
//			}
//
//		}
//		cout<<endl;
//	}

	return 0;
}
