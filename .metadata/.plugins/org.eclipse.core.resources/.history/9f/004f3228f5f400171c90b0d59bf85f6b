#include <iostream>
#include <math.h>
#include <time.h>
#include <limits.h>
#include <vector>
using namespace std;

struct BIT{
	int N;
	int* tree;

	BIT(int N){
		this->N = N;
		this->tree = new int[N+1]();
	}

	void add(int idx ,int val){ //adds val to a[idx]
	    while (idx <= N){
	        tree[idx] += val;
	        idx += (idx & -idx);
	    }
	}

	int cumulativeSum(int idx){ //returns a[1]+...+a[idx]
		int sum = 0;
		while (idx > 0){
			sum += tree[idx];
			idx -= (idx & -idx);
		}
		return sum;
	}

	int rangeSum(int l, int r){ //returns a[l]+...+a[r]
		return cumulativeSum(r) - cumulativeSum(l-1);
	}

	int get(int idx){ //get a[idx]
		int sum = tree[idx];
		if (idx > 0){
		    int z = idx - (idx & -idx);
		    idx--;
		    while (idx != z){
		        sum -= tree[idx];
		        idx -= (idx & -idx);
		    }
		}
		return sum;
	}

	/* RMQ */
	int constructRec(int* a, int l, int r, int idx){ //construct tree recursively for a[l..r]
		if(l==r){ //if there's only one element
			tree[idx] = a[l];
			return tree[idx];
		}

		int m = l + (r-l)/2;
		tree[idx] = min(constructRec(a, l, m, 2*idx+1), constructRec(a, m+1, r, 2*idx+2));
		return tree[idx];
	}

	BIT(int n, int* a){ //construct BIT for an array of size n, for RMQ

		int h = (int)(ceil(log2(n))); //height of segment tree
		this->N = 2*(int)pow(2, h) - 1; //maximum size of segment tree
		this->tree = new int[this->N]();

		constructRec(a, 0, n-1, 0); //construct tree from idx = 0 (root)
	}

	int RMQRec(int tl, int tr, int ql, int qr, int idx){ //return min(a[ql..qr]) from tree[tl..tr]
		if(ql>=tl&&qr<=tr) //if the query segment is included in the tree segment
			return tree[idx];
		if(qr<tl||ql>tr) //if the query segment is outside the tree segment
			return INT_MAX;
		int m = tl + (tr-tl)/2;
		return min(RMQRec(tl, m, ql, qr, 2*idx+1), RMQRec(m+1, tr, ql, qr, 2*idx+2));
	}

	int RMQ(int n, int ql, int qr){ //return min(a[ql..qr])
		return RMQRec(0, n-1, ql, qr, 0);
	}

};

struct Tree{
	int value;
	vector<Tree*> children;

	Tree(int value){
		this->value = value;
	}

	void addChild(Tree* child){
		children.push_back(child);
	}

};

vector<int> eulerTour(Tree* t){
	vector<int> v;
	v.push_back(t->value);
	if(t->children.size()==0) //if no children
		return v;
	for(Tree* child : t->children){
		vector<int> vc = eulerTour(child);
		v.insert(v.end(), vc.begin(), vc.end());
		v.push_back(t->value);
	}
	return v;
}

vector<int> levelTour(Tree* t, int l){
	vector<int> v;
	v.push_back(l);
	if(t->children.size()==0) //if no children
		return v;
	for(Tree* child : t->children){
		vector<int> vc = levelTour(child, l+1);
		v.insert(v.end(), vc.begin(), vc.end());
		v.push_back(l);
	}
	return v;
}

vector<int> occurrence(vector<int> eulerTour){
	vector<int> v;
	int i=1, pos=1;
	for(int x:eulerTour){
		if(x==i)
			v.push_back(pos);
		i++;
		pos++;
	}
}

int countSolutionsRec(int a, int b, int c) {
	if (a == 0) return 1;
	int f = 0, e = a & ~b & ~c;
	while (e != 0) {
		int d = e & -e;
		f += countSolutionsRec(a - d, (b + d) << 1, (c + d) >> 1);
		e -= d;
	}
	return f;
}

int countSolutions(int n) {
	return countSolutionsRec(~(~0 << n), 0, 0);
}

int main() {

	/* BIT */
//	int N = 50000;
//	BIT bit = BIT(N);
//
//	clock_t t1 = clock();
//
//	for(int i=1;i<=N;i++)
//		bit.add(i, i);
//	for(int i=1;i<N;i++)
//		bit.cumulativeSum(i);
//
//	clock_t t2 = clock();
//	cout<<"BIT takes : "<<t2 - t1<<" clock cycles."<<endl;
//
//	int* a = new int[N+1]();
//	int sum = 0;
//	for(int i=1;i<=N;i++)
//		a[i] = i;
//	for(int i=1;i<N;i++){
//		sum = 0;
//		for(int j=1;j<=i;j++)
//			sum += a[j];
//	}
//
//	cout<<"Array takes : "<<clock() - t2<<" clock cycles."<<endl;

	/* RMQ */
//	int a[10] = {2, 4, 3, 1, 6, 7, 8, 9, 1, 7};
//	BIT bit = BIT(10, a);
//	cout<<bit.RMQ(10, 2, 7);

	Tree** tree = new Tree*[14];
	for(int i=1;i<=13;i++)
		tree[i] = new Tree(i);
	tree[10]->addChild(tree[12]);
	tree[10]->addChild(tree[13]);
	tree[7]->addChild(tree[10]);
	tree[7]->addChild(tree[11]);
	tree[6]->addChild(tree[8]);
	tree[6]->addChild(tree[9]);
	tree[3]->addChild(tree[5]);
	tree[3]->addChild(tree[6]);
	tree[3]->addChild(tree[7]);
	tree[1]->addChild(tree[2]);
	tree[1]->addChild(tree[3]);
	tree[1]->addChild(tree[4]);

	vector<int> v = levelTour(tree[1], 0);
	for(int x:v)
		cout<<x;

//	cout<<countSolutions(15)<<endl;

	return 0;
}
